/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "STD_TYPES.h"
#include "BIT_MATH.h"

#include "RCC_interface.h"
#include "DIO_interface.h"
#include "EXTI_interface.h"
#include "NVIC_interface.h"
#include "SSD_int.h"
#include "Heater_interface.h"
#include "Cooler_interface.h"
#include "SSD_int.h"
#include "ADC_int.h"
#include "STK_interface.h"


typedef enum
{
	OFF_STATE,
	NORMAL_MODE_STATE,
	SETTING_MODE_STATE
}State_t;
State_t state = OFF_STATE;
u8 TEMP_Ref_value = 35; /* Setting Mode */
u16 TEMP_Current_value = 0; /* Normal Mode */
u8 settingCounter = 0 ;
u8 flag_toggle = 0 ;
u8 flag_down = 0;
u8 flag_up = 0;
u16 x ;
u16 y ;
void SwitchOnOff(void)
{
	if( state == OFF_STATE )
	{
		state = NORMAL_MODE_STATE;
	}
	else if( state == NORMAL_MODE_STATE || state == SETTING_MODE_STATE)
	{
		state = OFF_STATE ;
	}
}
void TEMP_UP(void)
{
	if( state == NORMAL_MODE_STATE || state == SETTING_MODE_STATE)
	{
		state = SETTING_MODE_STATE ;
	}
	settingCounter = 0 ;
	flag_up = 1 ;
	flag_toggle = 1 ;
}

void TEMP_DOWN(void)
{
	if( state == NORMAL_MODE_STATE || state == SETTING_MODE_STATE)
	{
		state = SETTING_MODE_STATE ;
	}
	settingCounter = 0 ;
	flag_down = 1 ;
	flag_toggle = 1 ;
}

void ACTION(void)
{
	if( state == SETTING_MODE_STATE ||  state==NORMAL_MODE_STATE )
	{
		settingCounter++ ;

		flag_toggle ^= 1 ;

		if(settingCounter==10)
		{
			state = NORMAL_MODE_STATE ;
		}
	}
}
int main(void)
{
	u16 tmep_arr[10] = {0};
	u16 tmep_sum = 0;
	u8 i = 0;
	EXTI_PinConfig_t Local_EXTI0 = {EXTI_u8_PORTA,PIN1,EXTI_u8_FALLING_EDGE,SwitchOnOff};
	EXTI_PinConfig_t Local_EXTI1 = {EXTI_u8_PORTA,PIN2,EXTI_u8_FALLING_EDGE,TEMP_DOWN};
	EXTI_PinConfig_t Local_EXTI2 = {EXTI_u8_PORTA,PIN3,EXTI_u8_FALLING_EDGE,TEMP_UP};
	/* RCC Initialize */
	MRCC_voidSysClkInit();
	/* GPIOA Enable Clock */
	MRCC_voidEnablePerClk(RCC_APB2,DIO_A);
	/* GPIOC Enable Clock */
	MRCC_voidEnablePerClk(RCC_APB2,DIO_C);
	MRCC_voidEnablePerClk(RCC_APB2,0);
	/* Init SSD */
	H_SSD_Void_init();
	/* Init HEATER & COOLER */
	H_HEATER_void_init();
	H_COOLER_void_init();
	/* Init STK */
	STK_voidInit();
	STK_voidSetIntervalPeriodic(500000, ACTION) ;
	// Set ADC Prescaler
	MRCC_voidSetADCPre(RCC_ADC_PRE_2);
	// Enable Per Clk "RCC" -> ADC -> 9
	MRCC_voidEnablePerClk(RCC_APB2,9);
	// Set Direction for ADC channel_0 as IN_ANALOG
	M_DIO_void_setPinDir(PORTA, PIN0, IN_ANALOG);
	/* Init ADC */
	ADC_void_init();

	/* IO Pins Initialization */
	M_DIO_void_setPinDir(PORTA,PIN1,IN_PULL_UP_DOWN); /* A0 Input Floating        */
	M_DIO_void_setPinVal(PORTA,PIN1,DIO_HIGH);
	M_DIO_void_setPinDir(PORTA,PIN2,IN_PULL_UP_DOWN); /* A1 Input Floating        */
	M_DIO_void_setPinVal(PORTA,PIN2,DIO_HIGH);
	M_DIO_void_setPinDir(PORTA,PIN3,IN_PULL_UP_DOWN); /* A2 Input Floating        */
	M_DIO_void_setPinVal(PORTA,PIN3,DIO_HIGH);

	M_DIO_void_setPinDir(PORTC,PIN14,OUT_2MHZ_PP); /* C14 Output        */
	M_DIO_void_setPinDir(PORTC,PIN15,OUT_2MHZ_PP); /* C15 Output        */
//	M_DIO_void_setPinVal(PORTC,PIN14,DIO_HIGH);
//	M_DIO_void_setPinVal(PORTC,PIN15,DIO_HIGH);



	/* EXTI Initializtion */
	EXTI_u8PinInit(&Local_EXTI0);
	EXTI_u8PinInit(&Local_EXTI1);
	EXTI_u8PinInit(&Local_EXTI2);
	EXTI_u8IntEnable(&Local_EXTI0);
	EXTI_u8IntEnable(&Local_EXTI1);
	EXTI_u8IntEnable(&Local_EXTI2);

	/* Enable EXTI0 from NVIC */
	NVIC_u8EnableInterrupt(7); /* EXTI0 */
	NVIC_u8EnableInterrupt(8); /* EXTI1 */
	NVIC_u8EnableInterrupt(9); /* EXTI2 */


	/* Loop forever */
	while(1)
	{
		switch(state)
		{
		case OFF_STATE:
			/* Disable Heater & Cooler & SSD*/
			H_HEATER_void_stop();
			H_COOLER_void_stop();
			H_SSD_Void_DisplayOFF();
			break;
		case NORMAL_MODE_STATE:
			x = ADC_u16_read(CHANNEL_0);
			tmep_arr[i] = ADC_u16_read(CHANNEL_0);
			tmep_sum += tmep_arr[i];
			if(i == 9)
			{
				TEMP_Current_value = (((tmep_sum / 10) * (u32)330) / 4096);
				tmep_sum = 0;
				i = 0;
			}
			i++;
			H_SSD_Void_DisplayNumber(TEMP_Current_value);
			if(TEMP_Current_value < TEMP_Ref_value)
			{
				H_HEATER_void_start();
				H_COOLER_void_stop();
			}
			else if(TEMP_Current_value > TEMP_Ref_value)
			{
				H_HEATER_void_stop();
				H_COOLER_void_start();
			}
			break;
		case SETTING_MODE_STATE:
			/* SET ref temp value */
			H_HEATER_void_stop();
			H_COOLER_void_stop();

			if(flag_toggle == 1)
			{
				H_SSD_Void_DisplayNumber(TEMP_Ref_value);
			}
			else
			{
				H_SSD_Void_DisplayOFF() ;
			}

			if(flag_up == 1 && TEMP_Ref_value < 75 )
			{
				TEMP_Ref_value += 5 ;
				flag_up = 0 ;
			}
			else if(flag_down == 1 && TEMP_Ref_value > 35 )
			{
				TEMP_Ref_value -= 5 ;
				flag_down = 0 ;
			}
			break;
		default: break;
		}
	}

}
